# Programmer - Portfolio S2

<style>

img + em {
  text-align: center;
}

</style>

## Sommaire

- [Programmer - Portfolio S2](#programmer---portfolio-s2)
  - [Sommaire](#sommaire)
  - [Composantes essentielles](#composantes-essentielles)
    - [En étant à l’écoute des besoins du client et des différents acteurs impliqués](#en-étant-à-lécoute-des-besoins-du-client-et-des-différents-acteurs-impliqués)
    - [En utilisant une approche rigoureuse et méthodique (démarche scientifique)](#en-utilisant-une-approche-rigoureuse-et-méthodique-démarche-scientifique)
    - [En choisissant les outils et l’environnement de développement adaptés](#en-choisissant-les-outils-et-lenvironnement-de-développement-adaptés)
    - [En intégrant les problématiques de sécurité](#en-intégrant-les-problématiques-de-sécurité)
  - [Apprentissages critiques](#apprentissages-critiques)
    - [Utiliser un système informatique et ses outils](#utiliser-un-système-informatique-et-ses-outils)
    - [Lire, comprendre, exécuter, corriger et modifier un programme](#lire-comprendre-exécuter-corriger-et-modifier-un-programme)
    - [Comprendre et traduire un algorithme, dans un langage et pour un environnement donné](#comprendre-et-traduire-un-algorithme-dans-un-langage-et-pour-un-environnement-donné)
    - [Connaître l’architecture et les technologies d’un site Web](#connaître-larchitecture-et-les-technologies-dun-site-web)
    - [Adapter le format de stockage et de transport des données au besoin de l’application](#adapter-le-format-de-stockage-et-de-transport-des-données-au-besoin-de-lapplication)
    - [S’intégrer dans un environnement propice au développement et au travail collaboratif](#sintégrer-dans-un-environnement-propice-au-développement-et-au-travail-collaboratif)
  - [Copyright © 2022-2023 Alexis Opolka - All Rights Reserved](#copyright--2022-2023-alexis-opolka---all-rights-reserved)

<div class="page" />

## Composantes essentielles

- <details>
  <summary>

  ### En étant à l’écoute des besoins du client et des différents acteurs impliqués

  </summary>

  Être à l'écoute des besoins de différents acteurs, qu'ils soient un client,
  une équipe interne ou externe, revient à être capable de s'adapter au niveau
  de dialogue nécessaire en fonction de l'interlocuteur.  
  C'est aussi avoir une structure de projet permettant d'obtenir des retours de la part
  des différents acteurs au moment le plus propice.

  En informatique, la structure de projet préférée, tout du moins à la date d'écriture
  de ce portfolio, est la structure Agile.  
  La méthode Agile comporte des avantages pour les projets nécessitant des itérations
  plutôt "rapides" et des retours de différents acteurs tout au long du développement
  et non à une étape précise.

  J'ai pu et dû, tout naturellement, être à l'écoute des besoins d'un ou plusieurs
  clients lors de différents projets dans différents cadres qu'ils soient universitaire
  ou professionnel.

  - Dans le cadre de la SAE-23, je me suis retrouvé à travailler en binôme, binôme qui
    est devenu, ce que je pourrais considérer, mon client interne au projet, et j'avais
    comme client externe les spécificités et le cahier des charges de la SAE, donc le département R&T
    de l'IUT de Béziers.

    Aspirant ingénieur DevOps, j'ai naturellement adopté une posture Agile sur le projet et j'ai itéré
    un certain nombre de fois en prenant en compte les besoins et les spécificités de chaque
    acteur en vérifiant bien que mon travail soit capable de venir s'intégrer au travail effectué
    par mon binôme.

    Plusieurs outils m'ont permis d'arriver à ses fins, tels que Discord ou encore GitHub.

    > **Note**:  
    > Chaque outil à ses forte et ses points négatifs, GitHub m'a permit de discuter
    > de problèmes sur des commits ou des Pull Requests où la discussion est liée au code.
    >
    > Discord a plus été utilisé afin d'avoir un service de messagerie instantanée permettant
    > d'échanger rapidement sur des points qui ne sont pas forcément directement liés au code.

  - Dans le cadre de la SAE-24, j'ai travaillé sur un projet lié au festival du fantastique
    de Béziers (FFB). Le projet était répartit en deux équipes de deux personnes.

    Je me suis alors retrouvé avec trois acteurs distincts:

    - L'IUT de Béziers

      J'ai eu comme client l'IUT car le projet, s'il se voit être mis en oeuvre,
      sera partie intégrante de l'évènement représentant l'IUT (i.e. Festival du Fantastique de Béziers).

      Ce client a des besoins tout spécifiques comme le matériel utilisé, la capacité du projet
      à venir s'intégrer de la manière la plus fluide possible dans un système déjà complexe.  
      En plus de cela, vient s'ajouter la question de faisabilité et de viabilité car l'on parle
      d'une institution du domaine publique et les délais de développement sont très courts avant
      que le projet ne soit considéré comme non viable.

      J'ai, tout au long de la SAE, communiqué avec l'IUT par le biais du directeur de l'IUT de Béziers ou de la directrice
      administrative des services administratifs, financiers et techniques afin d'itérer sur l'idée du projet
      et de son fonctionnement ainsi que sur les questions de logistique ou autres pouvant venir perturber l'organisation
      du Festival.

      J'ai principalement échangé à l'oral et par mail via le service mail Zimbra.

    - Le département R&T de l'IUT de Béziers

      J'ai eu comme client primaire le département R&T car avant d'être un projet pour le FFB, c'était
      un projet ayant vocation à être noté dans le cade de mes études et certaines contraintes ont du
      être respectées au risque d'être hors sujet et de ne pas respecter le travail à effectuer.

      J'ai, à nouveau, beaucoup échangé à l'oral de par le besoin d'accorder la SAE et le FFB lors des premiers
      jours du projet où mon équipe n'était pas la seule à avoir ce besoin et le professeur en charge de la
      supervision ne pouvait donc se permettre, en termes de disponibilité, de regarder ses mails à interval assez régulier
      pour en faire un moyen de communication pertinant lors de requêtes ayant un caractère important.  

    - L'autre équipe en binôme

      Travaillant sur un même système mais sur un sous-sytème différent, il a été primordial de trouver un moyen
      de s'accorder entre les binômes que ce soit à un niveau technique, en termes d'I/O, ou plus sur l'idée générale
      et de la vision de chacun sur la manière dont on devait procéder.  

      J'ai eu l'accord et ai utilisé des GitHub Projects au sein de l'organisation [IUT-Beziers](https://github.com/IUT-Beziers/)
      sur GitHub qui sont liés au [dépôt GitHub](https://github.com/IUT-Beziers/ffb-rfid/) et m'ont permit, ainsi qu'aux autres,
      de travailler de manière collaborative tout en restant à l'écoute des besoins de chacun.

  Je suis aussi confronté au besoin d'être à l'écoute de différents acteurs lorsque je contribue à des projets open-source sur GitHub
  tels que la [documentation officielle GitHub](https://github.com/github/docs/) où un résumé de ma contribution est disponible [ici](https://github.com/search?q=repo%3Agithub%2Fdocs+alexis-opolka&type=issues).

  Tout ceci me faisant dire, et penser, de ma capacité à communiquer avec différents acteurs d'un projet en adaptant mon discours en fonction
  de mon interlocuteur dans un milieu professionnel.

  > **Note**:  
  > [Remonter au sommaire](#sommaire)

  </details>  <div class="page" />
- <details>
  <summary>

  ### En utilisant une approche rigoureuse et méthodique (démarche scientifique)

  </summary>

  Afin de pouvoir développer, ou toute autre tâche nécessitant
  de la méthodologie et une démarche scientifique, il est important
  d'aborder le problème de manière rigoureuse et méthodique.  
  C'est à dire d'être capable de découper un problème en sous-problèmes
  et ainsi résoudre un sous-problème à la fois.

  - Dans le cadre de la SAE-21, j'ai dû développer un réseau
    pour une entreprise, en prenant en compte les besoins
    de l'entreprise, une DMZ, le réseau FAI et des sites distants.

    Afin de s'assurer de ne pas perdre le fil de la conception,
    j'ai créé un schéma réseau avant de commencer le montage réseau
    sur Cisco Packet Tracer.

    <div style="text-align: center; color: rgb(180, 180, 180)">

    ![sae21-schema-reseau](../../sae-21/src/img/schema-reseau.drawio.svg)
    <span style="border-bottom: 1.5px solid rgb(180, 180, 180);"> *Schéma réseaux fait lors de la SAE-21* </span>

    </div>

    Ayant déjà préparé le schéma réseau et les accès de chacuns (par Groupes),
    j'ai pu commencer le montage, et par la suite, faire les tests
    me permettant de valider ou non, le bon fonctionnment de mon réseau.

    Cependant, avoir seulement une approche rigoureuse et méthodique ne suffit pas à
    résoudre une multitude de problèmes et d'issues qui peuvent apparaître lors de toutes tâches.

    Dans le cas de la SAE-21 et de Cisco Packet Tracer, je me suis vu confronté
    à des limitations propres à l'outil, qui m'ont obligé à revoir
    mon schéma réseau de manière incrémentale et itérative afin
    d'obtenir un réseau fonctionnel. Cela comprenant, mais n'en est pas limité,
    à l'incapacité de faire un DNS relay, l'impossibilité de sniffer tous les
    paquets passant sur un lien sans être dans le mode simulation, etc.

  > **Note**:  
  > [remonter au sommaire](#sommaire)

  </details> <div class="page" />
- <details>
  <summary>

  ### En choisissant les outils et l’environnement de développement adaptés

  </summary>

  Choisir des outils et un environnement de développement adapté à un
  projet ou à un cadre, n'est pas chose facile car cela requiert une connaissance
  des outils et des environnements, en plus d'avoir un recul et un regard
  critique sur chaque solution possible.

  De part mon expérience, j'ai pu apprendre à utiliser de nombreux
  outils et environnements de développement.

  Dans le cadre étudiant, du BUT R&T, j'ai pu utiliser des outils
  et des environnements de développement tels que [GitHub](https://github.com), [Visual Studio Code](https://code.visualstudio.com),
  [Visual Studio](https://visualstudio.microsoft.com), [GitKraken](https://gitkraken.com) ou d'autres encore.

  - Dans le cadre de la SAE-23, vu que j'ai dû développer une application web contenant une API en TypeScript et NextJS, j'ai utilisé:

    - GitHub pour stocker le code source en ligne
    - GitHub Projects pour gérer les tâches à effectuer
    - Visual Studio Code en tant qu'IDE
    - GitKraken et Git pour contrôler les versions du code source

      > **Note**:  
      > GitKraken est une interface graphique pour Git
      > qui, d'après moi, permet dans certaines situations
      > de mieux comprendre les conflits et de les résoudre.  
      > Leur Git Graph est l'un des plus notables de GitKraken.

    - Docker pour build et lancer l'application construite
    - Postman pour développer et tester l'API
    - ESLint pour vérifier la syntaxe du code source

  - Dans le cadre de la SAE-24 et du projet pour le
    Festival du Fantastique de Béziers, j'ai utilisé:

    - les GitHub Projects liés au [dépôt GitHub](https://github.com/IUT-Beziers/ffb-rfid/)
      permettant ainsi la capacité du projet à survivre la SAE ainsi
      que la tracabilité des efforts menés dans le cas que ce n'était
      pas qu'un simple projet fait durant les études avec le seul
      objectif d'accomplir la tâche donnée par un professeur mais
      c'était / et l'est un projet avec l'objectif d'être mis en place
      lors d'un évenement organisé par l'IUT.

  - Dans le cadre de la SAE-12, j'ai du utiliser VS Code et GitHub car
    ils étaient de facto à utiliser durant la SAE.

    Ceci dit, ce n'était pas une mauvaise chose car VS Code, grâce à sa modularité,
    permet à chacun d'avoir un éditeur de texte / IDE personnalisé en fonction de
    ses besoins et de ses envies. Quant à GitHub, cet un environnement qui permet
    de travailler de manière collaborative sur la base de dépôts utilisant la technologie
    [Git](https://git-scm.org) pour la gestion de versions.

  - Dans d'autres cadres et dans d'autres projets, j'ai pu utiliser
    beaucoup d'autres outils et environnements de développement
    tel que [GitLab](https://gitlab.com), [BitBucket](https://bitbucket.org), [AWS](https://aws.amazon.com), [GCP](https://console.cloud.google.com), [Azure DevOps](https://dev.azure.com), etc.

  Ce qui m'a permis d'apprendre les fonctionnalités de base de
  ces outils et environnements de développement, mais aussi
  de me sentir à l'aise avec l'idée d'être confronté à un nouvel
  outil, que ce soit dans le cadre universitaire, personnel ou encore
  professionnel.

  > **Note**:  
  > [remonter au sommaire](#sommaire)

  </details> <div class="page"/>
- <details>
  <summary>

  ### En intégrant les problématiques de sécurité

  </summary>

  La sécurité est un élément essentiel dans le développement d'une
  application, qu'elle soit interne ou externe.

  - Dans le cadre de la SAE-23, j'ai dû développer une application web
    qui permettait de gérer et de suivre les données récoltées par
    les Banzaii. Il était donc important d'avoir une gestion des
    comptes utilisateurs et de leurs permissions.

    A cela, s'ajoute le système d'authentification qui ne doit pas
    transmettre les données de l'utilisateur, notamment le mot de passe,
    en clair. Et encore d'autres problématiques de sécurité liées à l'accès de l'API, à l'accès des pages, etc.

    J'ai donc dû mettre en place un système d'authentification et de
    double authentification prenant en compte les problématiques de
    sécurité qu'une application unipage peut avoir.

    J'ai aussi dû mettre en place une gestion des droits d'accès
    et d'affichages de certains éléments de l'application.

    Qui, dans le cas de la SAE-23 et du fait que ce soit une
    application démonstrative, n'est pas complètement poussée
    notamment dû au court lapse de temps donné entre le début
    du projet et son rendu, ne me permettant pas, ainsi qu'à
    mon binôme, d'obtenir un résultat convenable ainsi que la
    prise en compte et la mise en place de solutions pour
    différents problèmes qu'ils soient techniques, sécuritaires
    ou autres.

  - Dans le cadre de la SAE-23 et de la SAE-24, j'ai sécurisé le dépôt GitHub en protégeant
    la branche principale, dite de production ou stable, en empêchant toutes personnes
    non autorisées à push des changements directement sur celle-ci sans passer par une Pull Request (PR).  
    En ajoutant à cela l'obligation d'obtenir une revue (ou `review` en Anglais) lors des PR sans quoi,
    l'on ne peut pas la merge, on crée un système de procédés possiblement plus lent mais où des risques
    de fuite de tokens ou d'informations sensible sont attenués.

  > **Note**:  
  > [remonter au sommaire](#sommaire)

  </details> <div class="page"/>

## Apprentissages critiques

- <details>
  <summary>

  ### Utiliser un système informatique et ses outils

  </summary>

  Un système informatique peut prendre de multiples formes, surtout
  de nos jours où l'envie est à l'intégration de services.  
  Un IDE peut être considéré comme un système informatique tout comme
  un site web.

  - Dans le cadre de la SAE-16 et la SAE-25 (Portfolio), j'ai eu à utiliser
    et à manipuler le site Moodle (accès à la modification restreint sur mon Portfolio),
    j'ai pu alors forcer une certaine langue, un thème, des blocs d'affichages, modifier
    les inscriptions au "cours" comprenant le début de l'inscription ainsi que sa fin.

    <div style="text-align: center; color: rgb(180, 180, 180)">

    ![inscriptions-portfolio](./src/moodle-inscriptions.png)
    <span style="border-bottom: 1.5px solid rgb(180, 180, 180);">
      *Inscription Moodle modifiée pour l'utilisateur alexis-opolka*
    </span>
    </div>

    Après quelques modifications, la page du portfolio ressemble à ça:

    <div style="text-align: center; color: rgb(180, 180, 180)">

    ![theme-portfolio](./src/theme-moodle.png)
    <span style="border-bottom: 1.5px solid rgb(180, 180, 180);">
      *Nouveau thème du Portfolio Moodle*
    </span>
    </div>

  - Dans le cadre de mes projets et de mes cours, comprenant mais
    ne se limitant pas, à la SAE-12, la SAE-23, la SAE-24, la SAE-21,
    la SAE-14 etc. j'ai utilisé [VS Code](https://code.visualstudio.com/)
    comme IDE.

    Depuis la mise à jour de Février 2023, la notion de [profile](https://code.visualstudio.com/updates/v1_76#_profiles)
    a enfin été implémentée et publiée dans la branche stable du logiciel (C'était une fonctionnalité en discussion depuis
    plus de deux ans).  
    Un `profile` nous permet de configurer les paramètres associés à l'état de VS Code incluant les thèmes, les extensions
    et les configurations, on peut les exporter, les enregistrer dans un `workspace`, les synchroniser entre les clients
    VS Code d'un même compte (avec la synchronisation des paramètres), etc.  

    > **Note**:  
    > Pour plus d'informations concernant les `profiles` de VS Code,
    > je vous redirige vers la [documentation](https://code.visualstudio.com/docs/editor/profiles).

    J'utilise, à l'instant où j'écris ce portfolio, un profil que j'ai conçu spécialement pour de la rédaction MarkDown.

    <div style="text-align: center; color: rgb(180, 180, 180)">

    ![vs-code-profile](./src/vs-code-profiles.png)
    <span style="border-bottom: 1.5px solid rgb(180, 180, 180);">
      *Screenshot de VS Code lors de l'écriture du portfolio pour montrer l'utilisation des `profiles`.*
    </span>
    </div>

    Quand exporté, le code ressemble à cela:

    ```json
    {
      "name": "Markdown",
      "settings": "{\"settings\":\"{\\r\\n  \\\"hediet.vscode-drawio.resizeImages\\\": null\\r\\n}\"}",
      "keybindings": "{\"keybindings\":\"// Place your key bindings in this file to override the defaultsauto[]\\r\\n[\\r\\n  {\\r\\n    \\\"key\\\": \\\"ctrl+alt+e\\\",\\r\\n    \\\"command\\\": \\\"editor.action.toggleWordWrap\\\"\\r\\n  },\\r\\n  {\\r\\n    \\\"key\\\": \\\"alt+z\\\",\\r\\n    \\\"command\\\": \\\"-editor.action.toggleWordWrap\\\"\\r\\n  }\\r\\n]\",\"platform\":3}",
      "extensions": "[{\"identifier\":{\"id\":\"alexandrefpgoncalves.violet-dream\",\"uuid\":\"3f2f7e17-8f4f-47cd-9a73-2accb12befac\"},\"displayName\":\"Violet Dream\"},{\"identifier\":{\"id\":\"bierner.github-markdown-preview\",\"uuid\":\"9f5a5fc9-8b23-4484-85c4-1438b82d8634\"},\"displayName\":\"GitHub Markdown Preview\"},{\"identifier\":{\"id\":\"bierner.markdown-checkbox\",\"uuid\":\"b0db4123-c5d9-4f45-bd2e-70738ebbb304\"},\"displayName\":\"Markdown Checkboxes\"},{\"identifier\":{\"id\":\"bierner.markdown-emoji\",\"uuid\":\"f595c9c1-28b5-415e-a55f-2deb4a8c3abd\"},\"displayName\":\"Markdown Emoji\"},{\"identifier\":{\"id\":\"bierner.markdown-footnotes\",\"uuid\":\"8c379296-feca-4544-853d-f085a1fc638f\"},\"displayName\":\"Markdown Footnotes\"},{\"identifier\":{\"id\":\"bierner.markdown-mermaid\",\"uuid\":\"f8d0ffc4-66bb-4a9c-8149-ef8f043691a1\"},\"displayName\":\"Markdown Preview Mermaid Support\"},{\"identifier\":{\"id\":\"bierner.markdown-preview-github-styles\",\"uuid\":\"5cbdf58a-694a-4aba-af08-61d00842eb03\"},\"displayName\":\"Markdown Preview Github Styling\"},{\"identifier\":{\"id\":\"bierner.markdown-yaml-preamble\",\"uuid\":\"b872af63-f9e1-438e-9462-0315abe9d3aa\"},\"displayName\":\"Markdown yaml Preamble\"},{\"identifier\":{\"id\":\"davidanson.vscode-markdownlint\",\"uuid\":\"daf8b44d-8aae-4da2-80c5-1f770219f643\"},\"displayName\":\"markdownlint\"},{\"identifier\":{\"id\":\"dooez.alt-catppuccin-vsc\",\"uuid\":\"e5e65f10-7303-4fb8-8717-2fa83da6aff1\"},\"displayName\":\"Alt Catppuccin for VSCode\"},{\"identifier\":{\"id\":\"hediet.vscode-drawio\",\"uuid\":\"ea6a6046-2132-421f-a984-664909fcf0b8\"},\"displayName\":\"Draw.io Integration\"},{\"identifier\":{\"id\":\"shardulm94.trailing-spaces\",\"uuid\":\"6ad45f5a-09ec-44e5-b363-867ddc1ec674\"},\"displayName\":\"Trailing Spaces\"},{\"identifier\":{\"id\":\"stevensona.character-count\",\"uuid\":\"308ce1be-606b-4a79-8a1b-03f560320ce2\"},\"displayName\":\"Character Count\"},{\"identifier\":{\"id\":\"tomoki1207.pdf\",\"uuid\":\"4386e6f6-ec10-4463-9d23-c24278718947\"},\"displayName\":\"vscode-pdf\"},{\"identifier\":{\"id\":\"yzane.markdown-pdf\",\"uuid\":\"f015bc3c-a098-4245-8765-615e002e09ab\"},\"displayName\":\"Markdown PDF\"},{\"identifier\":{\"id\":\"yzhang.markdown-all-in-one\",\"uuid\":\"98790d67-10fa-497c-9113-f6c7489207b2\"},\"displayName\":\"Markdown All in One\"}]"
    }
    ```

    > **Note**:  
    > L'export ci-dessus omet les `UI-State` qui correspond à l'état de l'interface utilisateur.  
    > Mis à part cela, le JSON est complètement valide et peut être importé sans soucis dans une
    > instance VS Code en tant que profile.  
    >
    > Il faut tout de même noter que si l'ont veut exporter un profile dans un fichier, l'extension
    > utilisée est `.code-profile` et non `.json`.

    > **Note**:  
    > Vous pouvez retrouver l'export du profile sur ce [Gist GitHub](https://gist.github.com/alexis-opolka/69fe0012eacf15aa8b64f4d43a0e6971).

  - Dans le cadre de tous projet demandant un travail collaboratif, j'essaie de travailler avec des
    environnements de collaboration, en l'occurence pour les projets universitaires tels que les SAE
    j'utilise GitHub, principalement car c'est le seul outil collaboratif que mes pairs ont déjà utilisé.

    Pour des projets, j'utilise aussi bien des GitHub Projects autant sous forme d'un diagramme de Gantt,
    qu'un tableau ou d'une manière de ranger dans des cases bien précises les tâches (Boards View):

    <div style="text-align: center; color: rgb(180, 180, 180)">

    ![github-projects-table-view](./src/github-projects-table.png "Github Projects Table View")
    <span style="border-bottom: 1.5px solid rgb(180, 180, 180);">
      *GitHub Projects en format tableau*
    </span>
    </div>

    <div style="text-align: center; color: rgb(180, 180, 180)">

    ![github-projects-gannt-view](./src/github-projects-gantt.png "Github Projects Gantt View")
    <span style="border-bottom: 1.5px solid rgb(180, 180, 180);">
      *GitHub Projects en format diagramme de Gantt*
    </span>
    </div>

    <div style="text-align: center; color: rgb(180, 180, 180)">

    ![github-projects](./src/github-projects.png "Github Projects Board View")
    <span style="border-bottom: 1.5px solid rgb(180, 180, 180);">
      *GitHub Projects en format `board`*
    </span>
    </div>

    Mais il existe aussi les `issues` qui permettent de faire remonter des problèmes
    ou des tâches à faire.

    <div style="text-align: center; color: rgb(180, 180, 180)">

    ![github-issues](./src/github-issues.png "Github Issues View")
    <span style="border-bottom: 1.5px solid rgb(180, 180, 180);">
      *Screenshot d'une issue ouverte lors de la SAE-24 afin de
      savoir les rendus et nous permettre de nous situer.*
    </span>
    </div>

    Sans oublier les Pull Requests (PR) qui viennent accompagner les issues
    en proposant des changements. Les PR peuvent aussi contenir des discussions
    de changements mais cette fois-ci liés au code suggéré.

    <div style="text-align: center; color: rgb(180, 180, 180)">

    ![github-projects](./src/github-pr-1.png)
    <span style="border-bottom: 1.5px solid rgb(180, 180, 180);">
      *Screenshot montrant la page "d'accueil" d'une PR*
    </span>
    </div>
    <div style="text-align: center; color: rgb(180, 180, 180)">

    ![github-projects](./src/github-pr-2.png)
    <span style="border-bottom: 1.5px solid rgb(180, 180, 180);">
      *Screenshot montrant une résolution de problèmes au sein d'une PR*
    </span>
    </div>

    Que ce soit dans le cadre universitaire comme plus haut ou dans le cadre professionnel
    et personnel.

    <div style="text-align: center; color: rgb(180, 180, 180)">

    ![github-pr-on-github-docs](./src/github-pr-example.png)
    <span style="border-bottom: 1.5px solid rgb(180, 180, 180);">
      *Screenshot montrant un de mes échanges lors d'une PR chez [GitHub Docs](https://github.com/github/docs/)*
    </span>
    </div>

  </details> <div class="page" />
- <details>
  <summary>

  ### Lire, comprendre, exécuter, corriger et modifier un programme

  </summary>

  Quand on travaille en équipe, il est indispensable d'être capable de lire
  et comprendre le programme écrit par quelqu'un d'autre afin de l'exécuter
  et, si nécessaire, soit le corriger soit le modifier pour l'adapter à ses besoins.

  - Dans le cadre de la SAE-15, j'ai du travailler en binôme avec comme objectif de SAE
    le fait de récupérer des données provenant de l'OpenData de l'agglomération de Montpellier.

    Pour ce faire, la charge de travail avait été répartie entre nous deux et il s'est avéré
    être rapidement nécessaire d'être capable de comprendre la logique derrière le code de
    mon binôme afin de pouvoir l'aider à débugger sur sa partie ou au moment où j'importais
    son code et ses I/O dans mon code pour intégrer les deux parties.

  - Dans le cadre de la SAE-23, j'ai du créer à partir de presque rien un système d'authentification
    en TypeScript (TS) sur ReactJS et NextJS où j'avais comme support un exemple fait par [Jason Watmore](https://github.com/cornflourblue/next-js-13-mysql-registration-login-example)
    en JavaScript (JS) et la théorie derrière un système CRUD (Create, Read, Update, Delete).

    Il m'a fallu donc comprendre en plus de la logique derrière la programmation faite par Jason Watmore,
    ajouter une couche d'abstraction afin d'imaginer les interactions entre les acteurs du système et de
    la manière dont je pouvais l'implémenter dans mon cas particulier et en TS au lieu d'être en JS.

    Réussir à passer du code en JS à un schéma tel que celui-ci:

    ```mermaid
    ---
      title: Graph representing the interactions between each Component Holder of the Mon-Banzaii Project
    ---
    flowchart LR

        client(web client) --> | sends login data | middleWare(Middle Ware Client-Side)
        middleWare --> | sens API request | api(Authentication API)
        api --> | hash sensitive Data | apiMiddleWare(Middle Ware Server-Side)
        apiMiddleWare --> | sends hashed Data | api
        api --> | sends authentication response | client
    ```

  - Dans le cadre de la SAE-24, étant (implicitement) le chef de projet et (explicitement) le mainteneur
    du dépôt GitHub, j'étais en charge de toutes les revues de changement de code lors d'une PR.

    Il m'a alors été nécessaire de savoir comprendre et corriger le code proposé afin de m'assurer de
    ne pas casser la branche `main` (branche sensible à la casse). La plupart du temps, je n'ai pas eu
    besoin d'exécuter le code pour trouver des erreurs de logique ou des erreurs de programmation.

    <div style="text-align: center; color: rgb(180, 180, 180)">

    ![github-pr-correction](./src/github-pr-changes.png)
    <span style="border-bottom: 1.5px solid rgb(180, 180, 180);">
      *Screenshot montrant un de mes changements dans le code proposé afin de le rendre plus modulable et enlever les tokens présents.*
    </span>
    </div>

  </details> <div class="page" />
- <details>
  <summary>

  ### Comprendre et traduire un algorithme, dans un langage et pour un environnement donné

  </summary>

  Comprendre et être capable de traduire un algorithme dans un langage de programmation
  peut se présenter dans un projet où l'on travaille dans un environnement et un langage
  où personne d'autres n'a, publiquement, créé d'implémentation de cet algorithme.

  - Dans le cadre de la SAE-22, j'ai dû implémenter un algorithme d'échantillonnage d'un signal
    en Python:

    ```python
    def createSamplingOfSignal(signal_to_sample, time_between_sample):
      time = []
      signal_sampled = []
      ### On force le passage en liste car sinon on ne peut pas pick
      ### les éléments comme on veut
      signal_to_sample_as_list = signal_to_sample.tolist()

      ### On va boucler dans les valeurs du signal à échantilloner
      ### On instaure un pas de la période d'échantillonnage (on compte déjà en ms)
      for i in range(0, len(signal_to_sample), time_between_sample):
        ### On remet le temps en ms (question d'indice à valeur indicative du temps de l'échantillon)
        time.append(i/1000)
        ### On ajoute notre échantillon
        signal_sampled.append(signal_to_sample_as_list[i])

      ### On retourne: le temps, notre signal échantillonné et la périodicité d'échantillonnage
      ### A noter: Si l'on voudrait suivre la convention du retour des fonctions de ce fichier
      ### Il faudrait inverser l'ordre entre le temps et le signal dans le retour
      return np.array(time), np.array(signal_sampled), time_between_sample
    ```

    puis obliger ce même algorithme à respecter le théorème de Shannon:

    ```python
    def createSamplingOfSignalRespectingShannon(signal_to_sample, time_between_sample):
      time = []
      signal_sampled = []
      signal_to_sample_as_list = signal_to_sample.tolist()

      ### On prend 3 et pas 2 afin de nous permettre de respecter la condition
      ### du théorème de Shannon et de ne pas avoir à traiter avec un pas flottant.
      for i in range(0, len(signal_to_sample), time_between_sample//3):
        time.append(i/1000)
        signal_sampled.append(signal_to_sample_as_list[i])

      return np.array(time), np.array(signal_sampled), time_between_sample
    ```

  - Par simple curiosité de comment fonctionne l'algorithme de Dijkstra,
    j'ai implémenté à nouveau l'algorithme en Python sur une structure ressemblant
    celle d'un arbre binaire (sauf que la condition de binarité n'est pas respectée).

    Avec un peu de dynamisme dans la structure et sur sa forme en plus du point de départ
    et d'arrivée, l'implémentation a été un succès, en omettant quelques besoins d'optimisation.

  </details> <div class="page"/>
- <details>
  <summary>

  ### Connaître l’architecture et les technologies d’un site Web

  </summary>

  L'architecture d'un site web se compose principalement de deux éléments :

  - Le front-end
  - Le back-end

  Bien souvent, le front-end caractérise tout ce qui va se passer sur le client.  
  Le back-end caractérise, quant à lui, tout ce qui va se passer que ce soit sur
  les serveurs ou au niveau de l'infrastruture.

  > **Note**:  
  > De la définition que j'ai du back-end et du front-end, ce qui les différencie est
  > là où le code est executé / compilé. C'est à dire qu'un langage comme le PHP
  > où on peut développer une interface Front-End mais vu que le code PHP est
  > exécuté sur un serveur et non sur le client, il est caractérisé comme back-end
  > puisque ensuite c'est un code HTML qui est ressorti et c'est ce code qui sera
  > executé coté client.

  > **Notes**:  
  > Pour plus de détails sur la manière dont je comprends et j'en ai la définition,
  > je vous redirige vers cet [article](https://en.wikipedia.org/wiki/Frontend_and_backend) wikipedia
  > et plus spécialement la section [Web development as an example](https://en.wikipedia.org/wiki/Frontend_and_backend#Web_development_as_an_example)
  > qui précise et catégorise approximativement de la même manière la différence entre
  > backend et frontend.

  Je vais donc qualifier les langages de balisage tel que `HTML, XML, XHTML`,
  les langages de style tel que `CSS, SCSS`,
  et les langages de programmation tel que `JavaScript et TypeScript`
  comme étant des langages de front-end.  
  A contrario, je vais qualifier les langages `PHP`, `JavaScript`,
  les langages de bases de données comme `MySQL`, `PostgreSQL`, `InfluxQL`,`Flux (de InfluxDB)`, etc.
  comme étant des langages de back-end.

  > **Note**:  
  > Le JavaScript (JS) a capacité à être classé en tant que langage back-end
  > comme langage front-end de par les framework et libraires associées.

  Aux langages, je peux y ajouter les frameworks et les librairies qui, eux,
  sont bien plus nombreux.  
  Pour n'en citer qu'une infime partie :  

  - Pour les framework, nous avons `NextJS`, `VueJS`.
  - Pour les librairies, nous avons `ReactJS`, `JQuery`, `Bootstrap`, `Leaflet`.

  > **Note**:  
  > Pour plus de détails sur comment différencier une librairie ou un framework
  > je conseille cette [réponse](https://stackoverflow.com/a/15600924/13025136)
  > sur SO qui contient, en plus des explications, un schéma indiquant la logique
  > derrière la différentiation d'un framework à une librairie.

  En ce qui concerne les serveurs web, je peux citer les deux majoritaires
  du marché étant `Apache`, `Nginx` et `NodeJS`. <div class="page"/>

  En soit, je considère l'architecture d'un site web comme ceci :

  <div style="text-align: center">

  ![schema-architecture-website](./src/schema-architecture-website.drawio.svg)

  </div>

  On retrouve ce schéma notamment dans les [infrastructures Edge](https://en.wikipedia.org/wiki/Edge_computing) où la
  situation géographique des serveurs est un facteur pris en compte dans
  le déploiement et la mise en production.  
  En plus de cela, il y a une notion entre serveur principal (couche Cloud) et secondaire
  (couche Edge Node) où les informations émises par un client ne sont pas forcémment (voir rarement)
  remontées au serveur principal mais sont remontées au serveur secondaire
  en charge de la région où l'on observera ensuite une synchronisation du
  serveur principal avec le serveur secondaire (souvent avec des flux
  montants et descendants).

  Dans différents cadres j'ai été amené à développer un site web, que
  ce soit dans le cadre universitaire avec la [SAE-23](https://github.com/alexis-opolka/mon-banzaii/)
  où j'ai dû développer une application client permettant de lire des données récoltées
  dans une base de donnée et de pouvoir intéragir sur le nombre de Banzaiis,
  la [SAE-24](https://github.com/iut-beziers/ffb-rfid/tree/client-web/apps/ffb-watcher/) où
  j'ai du créer une interface utilisateur ayant le rôle d'inductrice d'informations
  nécessaires dans le système utilisé ultérieurement ou
  la [SAE-14](https://github.com/alexis-opolka/alexis-opolka.github.io) où
  j'ai du créer mon site web de présentation (que j'appelle aussi Portfolio).

  - Dans la SAE-23, j'ai eu à prendre en compte les caractéristiques du
    projet et ses contraintes afin de les transformer en besoins techniques
    et choisir les bonnes technologies. A savoir que les contraintes de temps
    ont été aussi prises en compte, ce qui a fait que je suis parti sur un
    stack comprenant:

    - NextJS
      Le framework nous permettant de développer en une seule distribution
      un coté serveur et un coté client tout en faisant du ReactJS.

      Je l'ai choisi notamment dû au besoin de développer tout un service
      de simple authentification à partir de *presque* rien aussi dit
      `from scratch` car il n'existe aucune librairie, à ma connaissance,
      nous permettant d'avoir un système d'authentificaton qui interragit
      avec la SGBD MySQL sous NodeJS et plus particulièrement ReactJS.
      Ainsi donc, j'ai du développer le système d'authentification en
      Typescript (afin de typer les entrées et sorties) du coté client
      et serveur.

    - Bootstrap / TailWindCSS

      J'ai choisi Bootstrap de par le fait que la librairie simplifie
      le prototypage avec des classes déjà prêtes et que l'on qu'à assembler.

      TailWindCSS vient de base avec l'application par défaut NextJS
      et mon binôme avait déjà commencé à l'utiliser, j'ai donc
      décidé de le garder et j'ai fait attention à ce que les
      deux librairies ne s'entrecroisent pas dans les déclarations
      de classes CSS pour chaque composant.

    - Next-UI

      La simplification de certains composants ReactJS
      et l'ajout de thèmes (même si le système n'est pas encore
      totalement implémenté).

    - React-Hook-Form

      Une librairie qui est dédiée aux formulaires en utilisant les
      hooks ReactJS et empêche un nombre de rendus excessifs.

      > **Note**:  
      > ReactJS "re-render" certains éléments sans même qu'il y ait besoin
      > et crée ainsi une charge exécutive excédentaire par rapport au
      > réel besoin logique (et logiciel) de ce que l'on fait.  
      > D'où l'importance des librairies comme `React-Hook-form` qui
      > sont dédiées à l'optimisation de la charge exécutive de certains
      > composants.

    - ChartJS

      Une librairie très pratique lorsque il est question de faire
      des graphiques dans une application ReactJS.

    - Minidenticons

      Une librairie trouvée sur GitHub qui permet de générer des avatars
      utilisateurs en fonction de leur pseudo.

    > **Note**:  
    > J'omets toutes les dépendances *techniques* du projet comme les wrapper
    > et les dépendances des dépendances. Seules sont citées plus hauts les
    > librairies / framework ayant fait l'objet d'un choix arbitraire.

  - Dans le cas de la SAE-24, vu que l'on travaillait avec des objets connectés
    et qu'ils communiquaient en LoRa, les spécificités ont été différentes d'une
    application client sans compter l'importance des données traitées par l'interface
    web en plus du fait que l'interface se trouvait en entrée du système.

    Je suis alors plus parti sur un site unipage (ReactJS) avec comme SGBD InfluxDB
    permettant d'obtenir toute la charge de calcul pour l'interface faite par le client
    et laisser la puissance de calcul du serveur pour le SGBD afin de minimiser la charge
    exécutive globale.

    Le choix d'InfluxDB s'est rapidement posé comme une évidence de par le contexte
    du projet et de la construction de notre base de donnée (BDD) et nos interactions
    avec elle.  
    Pour être plus précis, on avait besoin d'une interaction rapide, de
    multiples interactions successives et tout ça dans un lapse de temps plutôt court
    considérant que le client est à l'entrée du système et que l'on est obligé de faire en sorte
    que ce ne soit pas un point venant restreindre le flux du système.  
    Ainsi, la capacité d'InfluxDB à renvoyer que ce dont on a besoin sans avoir à charger
    toute une table / rangée de donnée est un point positif notable, en plus
    du fait que l'on pense InfluxDB quand on fait de l'IoT, ou AWS.

  - Dans le cadre professionnel / associatif, j'ai eu et j'ai à développer l'infrastructure réseau
    et le site web. Le site web est actuellement à portée nationale mais à vocation à
    se développer au niveau international.  

    Ses spécificités sont simples car il s'agit en premier d'un site vitrine et n'a pas
    besoin d'un système d'utilisateurs / d'authentification et donc de routes sécurisées.
    A contrario, vu qu'il représente l'association et ses projets il a des besoins tout
    spécifiques à l'image.

    C'est à dire qu'il est nécessaire d'avoir une redondance physique et technique,
    je me suis alors dirigé sur du IaaS (Infrastructure as a Service)
    où le site web se trouve être une application NextJS et est "build / served" par l'hébergeur,
    [DigitalOcean](https://digitalocean.com).  
    On compte deux environnements de travail, l'environnement de production,
    [petitspapiersdarchitecture.fr](https://petitspapiersdarchitecture.fr), et
    l'environnement de développement, [dev.petitspapiersdarchitecture.fr](https://dev.petitspapiersdarchitecture.fr).  
    L'environnement de production est l'environnement "stable", il n'est mis à jour que manuellement à partir de la branche
    `master` du dépôt GitHub alors que l'environnement de développement est instable et est sensible à la casse, il est déployé
    automatiquement à partir de la branche `develop` dès qu'un commit a été enregistré.

    > **Note**:  
    > Le dépôt GitHub en question est celui de l'organisation [Petits Papiers D'architecture](https://github.com/Petits-Papiers-Architecture),
    > il est pour l'heure en privé, il n'est alors pas possible d'y accéder sans faire partie de l'organisation GitHub.

    > **Note**:  
    > Le choix d'avoir l'application compilée par DigitalOcean me permet de réduire la charge de la gestion entière de l'infrastructure
    > mais je garde un contrôle sur la région des déploiments.  
    > C'est notamment dû au fait que je suis la seule personne au sein de l'association ayant les compétences requises pour gérer
    > l'infrastructure et le déploiement des applications.

    En plus de cela, vu que le projet à vocation d'être
    international, je suis parti sur une infrastructure Edge qui a des avantages notables en
    termes de scalabilité, efficacité et expérience utilisateur où l'emplacement géographique
    des serveurs joue un rôle clé dans l'équation globale.

  A partir de ce que j'ai pu montrer ci-dessus, je pense être capable de comprendre, concevoir et
  définir l'architecture d'un site web selon les besoins spécifiques des applications ou des circonstances
  y compris le temps dédié à la tâche.
  </details> <div class="page" />
- <details>
  <summary>

  ### Adapter le format de stockage et de transport des données au besoin de l’application

  </summary>

  Le format de stockage et de transport peuvent être différents selon les circonstances
  et les différents besoins. On peut très bien se retrouver avec du XML ou du CSV en stockage
  et du JSON en transport.

  Au moment où l'on interragit avec des données, qu'elles soient internes ou externes,
  on se retrouve confrontés à la problématique du format et il est d'utiliser celui qui
  convient le mieux à nos besoins.

  - Dans le cadre de la SAE-15, je devais créer un programme qui permettait de
    récolter des données sur l'API de la ville de Montpellier afin de pouvoir
    analyser et interpréter les données d'occupations des parkings à voitures
    et vélos de la ville.

    Pour ce faire, je devais récupérer les données au format XML et en GBFS.  
    J'ai donc préféré, avec mon binôme, d'utiliser le format CSV qui nous permettait
    facilement d'enregistrer en plus des données la date et l'heure de la requête
    effectuée et d'ainsi construire un historique des données.

    Ce n'est que plus tard, où je me suis penché sur l'analyse de données en utilisant
    InfluxDB et Grafana que je me suis rendu compte qu'il était plus préférable
    de travailler directement en Flux (le langage d'InfluxDB) au lieu d'avoir
    à tout transformer en CSV puis y traduire en Flux.  

    Malgré cet inconvénient (et travail en plus), le fait d'avoir déjà tout normalisé dans un format précis et d'une manière déterminée
    a permis, à mon binôme et à moi, d'importer les données récoltées
    dans la base de données pour ensuite sortir des graphes.

  - Dans le cadre de la SAE-23, j'ai dû travailler avec des données au format JSON
    où l'on avait des données qui étaient séparées en plusieurs fichiers et qui
    devaient contenir un historique des données.

    Si l'on prend par exemple les données considérées comme externes, j'avais une
    structure équivalente à celle ci-dessous:

    ```json
    {
      "id": "<ID-du-Banzaii>",
      "data": [
        {
          "type": "<Type-de-donnée>",
          "description": "<Description-des-données>",
          "timeline": [
            {
              "value": "<valeur>",
              "timestamp": "<timestamp>"
            },
            {
              "value": "<valeur>",
              "timestamp": "<timestamp>"
            }
          ]
        }
      ]
    }
    ```

  </details> <div class="page" />
- <details>
  <summary>

  ### S’intégrer dans un environnement propice au développement et au travail collaboratif

  </summary>

  Avant tout, on se doit de définir qu'est-ce qu'un environnement
  propice au développement puis qu'est-ce qu'un environnement propice
  au travail collaboratif.

  D'après moi, un environnement propice au développement est un
  environnement qui permet à un développeur ou à une équipe
  de pouvoir se concentrer sur le code en s'occupant des points
  sensibles et/ou techniques de tous projets.  
  C'est à dire que l'environnement doit notamment avoir un logiciel
  de gestion de version, un focus sur la codebase, un environnement
  de build et de déploiement, la possibilité de faire du CI/CD.

  Un environnement propice au travail collaboratif, de ce que j'en
  pense, doit permettre de discuter sur des problèmes dans des fils
  de discussion dédiés, un système de tickets, un système afin
  de pouvoir trier et catégoriser les informations.

  Ainsi, d'après moi, un environnement propice au développement
  et au travail collaboratif doit avoir l'ensemble des points
  cité ci-dessus, ou du moins, la majorité.  
  Il a donc un focus sur le code avec un logiciel de gestion de
  version, la possibilité de créer des tickets (aussi appelés issues)
  où la discussion peut se faire à part du code, un système de labels,
  etc.

  Il existe plusieurs environnements qui sont propices au développement et au travail collaboratif.  
  Je peux citer les plus connus qui sont GitHub, GitLab et BitBucket.  

  Etant utilisateur de GitHub depuis 2019-2020, j'ai eu l'occasion
  d'utiliser GitHub que ce soit pour des projets scolaires tels que
  la [SAE-15](https://github.com/alexis-opolka/sae-15-data/), la [SAE-12](https://github.com/alexis-opolka/sae-12/),
  la [SAE-21](https://github.com/alexis-opolka/sae-21/), la [SAE-23](https://github.com/alexis-opolka/Mon-Banzaii/)
  ou encore simplement pour [mes cours](https://github.com/alexis-opolka/import-cours-but-rt/).  
  J'ai aussi eu l'occasion d'utiliser GitHub pour des projets personnels ou pour contribuer à des projets open-source tels
  que [Ren'Py](https://github.com/renpy/renpy), [Code OSS](https://github.com/microsoft/vscode/), la [documentation GitHub](https://github.com/github/docs/), etc.

  Vous pouvez par exemple voir ci-dessous, comment la SAE-23 a été organisée de manière collaborative en utilisant les GitHub Projects.

  ![sae23-github-boards](./src/sae-23-boards.png)
  </details>

## Copyright &copy; 2022-2023 Alexis Opolka - All Rights Reserved